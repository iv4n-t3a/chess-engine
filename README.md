# Шахматный движок

## Oглавление:

* демо
* Сборка проекта
* Как пользоватся
* Как работает

## Демо:
![](demo.gif)

## Сборка проекта:

1. Установите `g++`, `git`, `make` и `sfml`
2. Соберите проект

		git clone https://github.com/iv4n-t3a/chess-engine
		cd chess-engine
		make

## Как пользоватся:

Вывод справки

	./chess --help

## Как работает:

т.к. я писал про базовые принцыпы, на которых работает движок в README.md проекта [шашек](https://github.com/iv4n-t3a/checkers-engine),
здесь я напишу только о том, что не использовал в том проекте.
Для лучшего понимания рекомендую ознакомится с шашками.

### Хранение ходов в памяти

Я кодирую каждый ход в 16-битном числе.
Т.к. я однозначно задаю любое перемещение фигуры таким числом, это позволяет заранее считать вспомогательную информацию для каждого типа хода.
Например хранение изменения доски позволяет легко проверить псевдолегальный ход
(ход совершенный по правилам перемещения фигуры, но возможно нарушающий некоторыедругие правила)
на легальность

Первые 2 бита хранят один из четырех типов хода

1. Обычный ход
2. Рокировка
3. Взятие на проходе
4. Превращение пешки

остальные 14 бит хранят всю необходимую информацию для однозначного задания этого хода
(начальное и кончное поле или начальную и конечную горизонталь, цвет совершающего ход игрока, тип рокировки, новая фигура)

### `Compile-time` вычисление всех возможных ходов

Для коня и короля легко вычислить все атакуемые ими поля(а по ним и ходы) заранее для каждой клетки доски.
Для 'скользящих фигур' воспользуемся инструкциями `pdep` и `pext`, для предварительного вычисления
всех возможных ходов при всех конфигурациях блокировщиков.
Суть в том, что для любого положения ладьи/слона есть не более 11 полей,
наличие/отсутствие фигур на которых может изменить набор атакуемых клеток.
Можно заранее вычислить маски с такими полями для каждого положения слона/ладьи и ,пользуясь ими и инструкциями `pdep` в `x86`
(К сожалению использование этой штуки нарушает совместимость с другими архитиктурами),
сбросить положение блокировщиков в начало битборды(в первые 11 бит).
Это позволяет заранее вычислить атакуемые поля для всех возможных положений скользящих фигур и всех возможных расположений других фигур,
влияющих на их поведение.

Для генерации атаки пешки следует использовать аналогичный прием, только с разделением на белые и черные пешки из-зи разных направлений движения.
Для генерации атаки ферзя следует использовать объединение атаки ладьи и слона.

### Сортировка ходов:

Эффективность альфа-бета отсечения повысится, если сначала рассматривать более выгодные ходы.
Для этого перед перебором ходов отсортируем их, учитывая следующие факторы

* Обычно взятие или шах - это хорошо
* Обычно превращение пешки - это хорошо
* Обычно рокировка - это хорошо
* Обычно ставить фигуру под пешку плохая идея

### Оценка позиции

Здесь учитываются следующие факторы:

* Материал, количество разных фигур, с разными коэфициентами
* Мобильность, количество возможных псевдолегальных ходов
* Наличие прав на рокировку
* Наличие пешек перед рокированным королем
* Преимущество двух слонов
* Слоны на главной диагонали
* Сдвоенные пешки
* Защищенные пешками пешки
